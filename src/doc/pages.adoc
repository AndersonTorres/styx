[[Pages]]
== Pages

Pages refer to the pages declared in `site.nix`.

Pages are declared in a `pages` an attribute set. Every page or list of pages declared in this set will be generated.


=== Overview

Pages get passed to the `generateFunction` that turn each page into a text file in the generated site.

TIP: Pages are usually generated as html documents, but any kind of text file can be generated from a page attribute set.


=== The page attribute set

The page attribute set is an attribute set that must defines at least three attributes:

* `layout`: A function that take the `template` result as a parameter and return the source of the file to generate.
* `template`: A function that take the page attribute set as a parameter and returns an updated attribute set.
* `href`: The path of the page to generate.

NOTE: This is the strict minimum and most of templates will require extra attributes like `content` or `title`.

<<Hello world!>> contains an example of a simple page attribute set.

[source, nix]
.Simple page attribute set
----
pages.index = {
  layout = template: "<html><body>${template}</body></html>";
  template = page: "<h1>Hello world!</h1>";
  href = "index.html";
};
----

In a normal `site.nix`, the template would be an attribute from the `templates` set like `templates.generic.full`.

Page attribute sets are usually augmented by various attributes or merged with data sets to fit any needs.

NOTE: `generateSite` evaluate `page.layout (page.template page)` and output the result in `page.href` for every page in its `pagesList` argument.

TIP: As many pages tends to use the same layout, the `layout` attribute is usually set in one go to all templates in the "arguments preparation" section. +
Usually, only pages that use a different layout explicitly declares it in `pages`. +
The following examples will omit the `layout` like done in a normal `site.nix`.


=== Simple pages

Generating a simple page is trivial as it is just declaring the required attributes.

[source, nix]
.Creating an error 404 page
----
pages.e404 = {
  href     = "404.html";
  template = templates.e404;
};
----

NOTE: Attribute set attributes should not start with a number. That is why the 404 template is `templates.e404` and not `templates.404`. +
Nix allow to use attributes starting with a number, but they must be called by using `"`. This is error prone and not used in styx.

=== Attaching data to a page

Generating a page from an imported data is a very common case, and is easy to achieve.

[source, nix]
.Attaching a data set to a page attribute set.
----
pages.about = {
  href = "about.html";
  template = templates.generic.full;
} // data.about;
----

The `//` operator will merge the `data.about` data set in the `about` page set.


=== Bypassing the layout

For pages which the template generate the full page source like for RSS feeds, applying a layout is not needed. +
In such cases, the `id` function, a function that return its parameter without changing it can be used as a layout.

[source, nix]
.Using id as a layout
----
pages.feed = {
  href = "feed.xml";
  template = templates.feed;
  posts = take 10 posts;
  layout = id;
};
----

NOTE: The `id` function is defined as `x: x`.

=== Split pages

Split pages refers to a list of data split though multiple similar pages.

A common example of split page is a blog archive page, the full list of blogs are split in many pages.

Split pages can be generated with the `mkSplit` or `mkSplitCustom` function. +
`mkSplit` being a simpler version of `mkSplitCustom` function that should fit most of needs.

[source, nix]
.mkSplit example
----
pages.archives = mkSplit {
  baseHref = "archives";
  template = templates.archives;
  itemsPerPage = 5;
  data = pages.posts;
};
----

This will create a list of pages attribute sets with the following extra attributes:

`href`:: Set accordingly to `baseHref`. `baseHref.html` for the first page, and `baseHref-i.html` for the following pages where `i` is the index of the page.
`items`:: The list of items for this page.
`index`:: The position of this page in the list of split pages.
`pages`:: The split pages lists, useful for generating a pagination.

For more complex splitting needs see the <<mkSplitCustom>> function documentation.

NOTE: `mkSplit` only requires `baseHref`, `itemsPerPage` and `data` as parameters. Any extra parameter passed will be added to every split page attribute set. +
This is on purpose and is used in the previous example to set all the split pages template in the `mkSplit` declaration.


=== Multipages

Multipages are page attribute sets that have a `subpages` attribute containing a list of subpages content.

Multipages are usually generated by importing <<Multipage data>>.

Mulipage pages are referred as:

* `all`: The full subpages list.
* `head`: First page in the subpages list.
* `tail`: All the subpages, but the first.

==== Single pages

Multipages can be generated with the `mkMultipages` function.

[source, nix]
.mkMultipages example
----
pages.about = mkMultipages ({
  template = templates.generic.full-multipage;
  baseHref = "about";
} // data.about);
----

NOTE: `mkMultipages` only requires `baseHref` and `subpages` as parameters. Any extra parameter passed will be added to every generated attribute attribute set.


==== Pages in a list

For a list of pages that might contains multipages, the problem get a little different.

If `mkMultipages` is naively used, every subpage will end up in the page list, and it is not what is expected most of the time.

If we have a list of posts, and some are multipages, we want the `pages.posts` list of pages to include single page posts and the first page of the any multipage post. +
That way, multipage post subpages will not end up in posts archives or in the RSS feed.

So for multipages in a list, the generation will be separated in two steps.

1. First generate the page list with single page data and multipage first page data.
2. Generate the multipage subpages data.

---

First step, generate the page set list with single page data and multipage first page data.

This could be done using `mkMultipages` and filtering / mapping, but a `mkPageList` function is available and do exactly that.

[source, nix]
.Generating the page list with multipage head pages
----
pages.posts = mkPageList {
  data = data.posts; # <1>
  multipageTemplate = templates.post.full-multipage; # <2>
  template = templates.post.full;
};
----

<1> `data` is a list of data attribute set to generate pages attribute set from.
<2> `multipageTemplate` is the template that will be used for data set that have a `subpages` field.

`mkPageList` will loop through `data` and if it finds a multipage, render only the first page (head) attribute set setting its template to `multipageTemplate` template.

---

Next step is to generate the `tail` of the multipages posts.

`mkMultitail` is the function to generate page sets for the `tail` of multipages in a list of data sets.

[source, nix]
.Generating the multipage posts tail
----
pages.multiPostsTail = mkMultiTail {
  data = data.posts;
  template = templates.post.full-multipage;
};
----

This is very similar to the `mkPageList` function but only tail pages sets are generated. As only tail pages are rendered, the template is directly set with the `template` attribute.

IMPORTANT: It is possible to set a prefix to the generated `href` attribute of `mkPageList` and `mkMultiTail` function with the `hrefPrefix` argument. +
If the `baseHref` argument is set, it **must** be the same for the same data set, else the links between `head` and `tail` pages will be broken.

=== Taxonomy pages

NOTE: To see how to generate taxonomy data, refer to <<Taxonomies>>.

Taxonomies pages can be generated from a taxonomy data structure with the `mkTaxonomyPages` function.

[source, nix]
----
  taxonomies = mkTaxonomyPages {
    data = data.taxonomies;
    taxonomyTemplate = templates.taxonomy.full;
    termTemplate = templates.taxonomy.term.full;
  };
----

The `mkTaxonomyPages` function will create the following page attribute sets:

- `TAXONOMY/index.html`, the taxonomy index page set for every taxonomy. A `terms` attribute will be added to the page attribute set containing all the taxonomy terms.
- `TAXONOMY/TERM/index.html`, the term index page set for every term in every taxonomy. A `values` attribute will be added to the page attribute set containing all the values that use the term.

NOTE: If required `mkTaxonomyPages` generated pages `href` can be changed with the `taxonomyHrefFun` and the `termHrefFun`, for details see <<mkTaxonomyPages>>. +
If any of these functions is changed, the templates should be updated accordingly.

